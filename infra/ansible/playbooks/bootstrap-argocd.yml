---
# ─────────────────────────────────────────────────────────────────
# Bootstrap ArgoCD + deploy Application CRDs
# Eliminates the manual ArgoCD install step
#
# Usage:
#   ansible-playbook -i inventory/dev.yml playbooks/bootstrap-argocd.yml
# ─────────────────────────────────────────────────────────────────

- name: Bootstrap ArgoCD on K3s cluster
  hosts: k3s_server
  become: true
  vars_files:
    - "{{ playbook_dir }}/../group_vars/all.yml"
  vars:
    argocd_wait_initial_sync: "{{ (lookup('env', 'ARGOCD_WAIT_INITIAL_SYNC') | default('false', true) | lower) in ['1', 'true', 'yes', 'on'] }}"
    argocd_sync_retries: "{{ lookup('env', 'ARGOCD_SYNC_RETRIES') | default('12', true) | int }}"
    argocd_sync_delay: "{{ lookup('env', 'ARGOCD_SYNC_DELAY') | default('10', true) | int }}"
  environment:
    KUBECONFIG: /etc/rancher/k3s/k3s.yaml
  # vars: argocd_version, argocd_namespace, project_repo → group_vars/all.yml

  tasks:
    # ─── Install ArgoCD ──────────────────────────────────────────
    - name: Create ArgoCD namespace
      shell: kubectl create namespace {{ argocd_namespace }} --dry-run=client -o yaml | kubectl apply -f -

    - name: Install ArgoCD manifests
      shell: kubectl apply -n {{ argocd_namespace }} -f https://raw.githubusercontent.com/argoproj/argo-cd/{{ argocd_version }}/manifests/install.yaml
      register: argocd_install

    - name: Wait for ArgoCD server to be ready
      shell: kubectl rollout status deployment/argocd-server -n {{ argocd_namespace }} --timeout=300s
      retries: 3
      delay: 10

    - name: Wait for ArgoCD application controller
      shell: kubectl rollout status statefulset/argocd-application-controller -n {{ argocd_namespace }} --timeout=300s
      retries: 3
      delay: 10

    - name: Wait for ArgoCD repo server
      shell: kubectl rollout status deployment/argocd-repo-server -n {{ argocd_namespace }} --timeout=300s
      retries: 3
      delay: 10

    # ─── Configure ArgoCD ────────────────────────────────────────
    - name: Read ArgoCD insecure mode
      shell: kubectl get configmap argocd-cmd-params-cm -n {{ argocd_namespace }} -o jsonpath='{.data.server\.insecure}'
      register: argocd_insecure_value
      changed_when: false
      failed_when: false

    - name: Enable ArgoCD insecure mode behind Traefik
      shell: |
        kubectl patch configmap argocd-cmd-params-cm -n {{ argocd_namespace }} \
          --type merge \
          -p '{"data":{"server.insecure":"true"}}'
      when: argocd_insecure_value.stdout != "true"

    - name: Restart ArgoCD server after insecure mode change
      shell: kubectl rollout restart deployment/argocd-server -n {{ argocd_namespace }}
      when: argocd_insecure_value.stdout != "true"

    - name: Wait for ArgoCD server rollout
      shell: kubectl rollout status deployment/argocd-server -n {{ argocd_namespace }} --timeout=300s
      when: argocd_insecure_value.stdout != "true"

    - name: Get ArgoCD initial admin password
      shell: kubectl -n {{ argocd_namespace }} get secret argocd-initial-admin-secret -o jsonpath='{.data.password}' | base64 -d
      register: argocd_password
      retries: 5
      delay: 10
      until: argocd_password.rc == 0

    - name: Display ArgoCD admin password
      debug:
        msg: "ArgoCD admin password: {{ argocd_password.stdout }}"

    # ─── Deploy ArgoCD Project ───────────────────────────────────
    - name: Copy ArgoCD project definition
      copy:
        src: "{{ playbook_dir }}/../../../argocd/projects/devboard-project.yaml"
        dest: /tmp/argocd-project.yaml

    - name: Apply ArgoCD project
      shell: kubectl apply -f /tmp/argocd-project.yaml

    # ─── Deploy ArgoCD Applications ──────────────────────────────
    - name: Copy ArgoCD application manifests
      copy:
        src: "{{ playbook_dir }}/../../../argocd/applications/"
        dest: /tmp/argocd-apps/

    - name: Read secrets file
      become: false
      local_action:
        module: slurp
        src: "{{ playbook_dir }}/../../../.env.secrets"
      register: secrets_file
      failed_when: false

    - name: Parse secrets from .env.secrets
      set_fact:
        db_username: "{{ (secrets_file.content | b64decode | regex_search('DB_USERNAME=(.+)', '\\1'))[0] | default('devboard') }}"
        db_name: "{{ (secrets_file.content | b64decode | regex_search('DB_NAME=(.+)', '\\1'))[0] | default('devboard') }}"
        db_password: "{{ (secrets_file.content | b64decode | regex_search('DB_PASSWORD=(.+)', '\\1'))[0] | default('changeme') }}"
        jwt_secret: "{{ (secrets_file.content | b64decode | regex_search('JWT_SECRET=(.+)', '\\1'))[0] | default('changeme') }}"
        grafana_admin_password: "{{ (secrets_file.content | b64decode | regex_search('GRAFANA_ADMIN_PASSWORD=(.+)', '\\1'))[0] | default('admin') }}"
      when: secrets_file.content is defined

    - name: Set fallback secrets if .env.secrets not found
      set_fact:
        db_username: "devboard"
        db_name: "devboard"
        db_password: "changeme"
        jwt_secret: "changeme-jwt-secret-minimum-32-chars"
        grafana_admin_password: "admin"
      when: secrets_file.content is not defined

    - name: Set deterministic Vault dev root token
      set_fact:
        vault_dev_root_token: "root"

    - name: Create or update Vault token secret for External Secrets operator
      shell: |
        kubectl create namespace external-secrets --dry-run=client -o yaml | kubectl apply -f -
        kubectl create secret generic vault-token \
          -n external-secrets \
          --from-literal=token='{{ vault_dev_root_token }}' \
          --dry-run=client -o yaml | kubectl apply -f -

    - name: Apply ArgoCD applications
      shell: kubectl apply -f /tmp/argocd-apps/
      register: apps_result

    - name: Display applied applications
      debug:
        msg: "{{ apps_result.stdout_lines }}"

    - name: Copy Vault policy to server
      copy:
        src: "{{ playbook_dir }}/../../../security/vault/policies/devboard-policy.hcl"
        dest: /tmp/devboard-policy.hcl
        mode: "0644"

    - name: Wait for Vault pod to become Ready
      shell: kubectl wait --for=condition=Ready pod -n security -l app.kubernetes.io/name=vault --timeout=300s
      register: vault_wait
      changed_when: false
      failed_when: false

    - name: Seed DevBoard secrets in Vault (single source of truth)
      shell: |
        VAULT_POD="$(kubectl get pod -n security -l app.kubernetes.io/name=vault -o jsonpath='{.items[0].metadata.name}')"
        kubectl cp /tmp/devboard-policy.hcl security/${VAULT_POD}:/tmp/devboard-policy.hcl
        kubectl exec -n security "${VAULT_POD}" -- sh -c "\
          export VAULT_ADDR=http://127.0.0.1:8200 && \
          vault secrets enable -path=secret kv-v2 2>/dev/null || true && \
          vault kv put secret/devboard/db username='{{ db_username }}' password='{{ db_password }}' host='devboard-app-postgres' port=5432 database='{{ db_name }}' && \
          vault kv put secret/devboard/jwt secret='{{ jwt_secret }}' && \
          vault kv put secret/devboard/grafana adminUser='admin' adminPassword='{{ grafana_admin_password }}' && \
          vault policy write devboard /tmp/devboard-policy.hcl \
        "
      when: vault_wait.rc == 0

    # ─── Wait for initial sync ───────────────────────────────────
    - name: Wait for ArgoCD applications to sync (initial)
      shell: |
        kubectl get applications -n {{ argocd_namespace }} -o jsonpath='{range .items[*]}{.metadata.name}: {.status.sync.status}{"\n"}{end}'
      register: sync_status
      retries: "{{ argocd_sync_retries }}"
      delay: "{{ argocd_sync_delay }}"
      until: "'OutOfSync' not in sync_status.stdout and 'Unknown' not in sync_status.stdout"
      changed_when: false
      failed_when: false
      when: argocd_wait_initial_sync

    - name: Skip initial sync wait (fast path)
      debug:
        msg: "Skipping initial ArgoCD sync wait. Set ARGOCD_WAIT_INITIAL_SYNC=true for strict mode."
      when: not argocd_wait_initial_sync

    - name: Display final sync status
      debug:
        msg: "{{ sync_status.stdout_lines }}"
      when: argocd_wait_initial_sync

    # ─── Save credentials ────────────────────────────────────────
    - name: Save ArgoCD credentials locally
      become: false
      local_action:
        module: copy
        content: |
          # ArgoCD Credentials (auto-generated)
          URL: http://argocd.devboard.local
          Username: admin
          Password: {{ argocd_password.stdout }}
        dest: "{{ playbook_dir }}/../argocd-credentials.txt"
        mode: "0600"
